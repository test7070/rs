z_modout_rs01:--z_modout_rs01

SET QUOTED_IDENTIFIER OFF

declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [1] then '' else [1] end
set @t_enoa= case when '#non' = [2] then char(255) else [2] end
-----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(50),
	modnoa nvarchar(50),
	mech nvarchar(40),
	datea nvarchar(50),
	code nvarchar(50),
	detail nvarchar(50),
	frame nvarchar(10),
	mount float,
	namea nvarchar(50),
	tmount float
)

insert into @tmp
select '0',ROW_NUMBER()over(partition by a.modnoa order by b.code),a.noa,a.modnoa,a.mech,a.datea,b.code,b.detail,b.frame,SUM(b.mount) 
,a.namea,0
from modout a
left join modouts b on a.noa = b.noa
where(a.noa between @t_bnoa and @t_enoa)
group by a.noa,a.modnoa,a.mech,a.datea,b.code,b.detail,b.frame,a.namea

update a
set tmount=(select sum(mount) from @tmp where a.noa=a.noa)
from @tmp a

declare @noa nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select noa from @tmp group by noa
open cursor_table 
fetch next from cursor_table 
into @noa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where noa = @noa)
	set @max = (select MAX(rec) from @tmp where noa = @noa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,noa)
		select '0',@max+1,@noa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @noa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by noa,rec;
--**************************************************************************
z_modout_rs02:--z_modout_rs02

SET QUOTED_IDENTIFIER OFF

declare @t_bnoa nvarchar(30)
declare @t_enoa nvarchar(30)

set @t_bnoa= case when '#non' = [3] then '' else [3] end
set @t_enoa= case when '#non' = [4] then char(255) else [4] end
-----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	noa nvarchar(50),
	tgg nvarchar(50),
	datea nvarchar(50),
	usetype nvarchar(50),
	frame nvarchar(50),
	code nvarchar(50),
	detail nvarchar(50),
	class nvarchar(10),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	datea1 nvarchar(50),
	datea2 nvarchar(50),
	times float,
	mount float,
	mech  nvarchar(50),
	worker  nvarchar(10)
)
insert into @tmp(gno,rec,noa,tgg,datea,usetype,frame,code)
select 
	'0',ROW_NUMBER()over(partition by a.noa order by c.nob),a.noa,a.tgg,a.datea,
	case when a.usetype='1' then '設備課' else '製造課' end,a.frame,b.productno
from model a
left join models b on a.noa = b.noa
left join modfixs  c on b.productno = c.nob
left join modfixcs  d on b.productno = d.nob
left join modfixcs  e on b.productno = e.nob
where (a.noa between @t_bnoa and @t_enoa)and
	  exists (select * from modfixs  where nob = b.productno)and
	  exists (select * from modfixcs where nob = b.productno)and
	  exists (select * from modouts  where nob = b.productno)
	  
declare @rec int
declare @noa nvarchar(50)
declare @xnoa nvarchar(50) = 'xxxxxx'
declare @code nvarchar(50)

declare cursor_table cursor for 
select noa,code from @tmp group by noa,code
open cursor_table 
fetch next from cursor_table 
into @noa,@code
while(@@FETCH_STATUS <> -1) 
begin
	if(@noa != @xnoa)
	begin
		set @rec = 2
		set @xnoa = @noa
	end	
	
	insert into @tmp(gno,rec,noa,code,detail,class,weight,way,datea1,mount,mech)
	select '1',@rec,@noa,@code,b.detail1,'入庫維修',SUM(b.weight1),b.way1,a.datea,SUM(b.mount1),a.mech 
	from modfix a
	left join modfixs b on a.noa = b.noa
	where(a.modnoa = @noa and b.nob = @code)
	group by b.way1,a.datea,a.mech,b.detail1
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,code,detail,class,bebottom,enbottom,way,datea1,datea2,mount,mech,worker,times)
	select '2',@rec,@noa,@code,b.detail,'維修',MIN(b.bebottom),MIN(b.enbottom),b.way,MIN(b.bdate+'-'+b.btime),MAX(b.edate+'-'+b.etime),SUM(b.mount),a.mech,b.worker
	,ROUND(sum((DATEDIFF(minute,CAST(dbo.ChineseEraName2AD(b.bdate)as nvarchar(20))+' '+b.btime ,CAST(dbo.ChineseEraName2AD(b.edate)as nvarchar(20))+' '+b.etime))/60.0),1)
	from modfixc a
	left join modfixcs b on a.noa = b.noa
	where(a.modnoa = @noa and b.nob = @code)
	group by b.detail,b.way,a.mech,b.worker
	set @rec = @rec + 1
	
	insert into @tmp(gno,rec,noa,code,detail,class,enbottom,datea1,mount,mech)
	select '3',@rec,@noa,@code,b.detail,'領用出庫',MIN(c.enbottom),a.datea,SUM(b.mount),a.mech
	from modout a
	left join modouts b on a.noa = b.noa
	left join modfixcs c on b.nob = c.nob
	where(a.modnoa = @noa and b.nob = @code)
	group by a.datea,a.mech,b.detail
	set @rec = @rec + 1

	fetch next from cursor_table 
	into @noa,@code
end 
close cursor_table 
deallocate cursor_table 

delete @tmp where gno = '0' and rec != 1

--update @tmp set times =
--ROUND((DATEDIFF(minute,CAST(dbo.ChineseEraName2AD(dbo.split(datea1,'-','0'))as nvarchar(20))+' '+dbo.split(datea1,'-','1') ,CAST(dbo.ChineseEraName2AD(dbo.split(datea2,'-','0'))as nvarchar(20))+' '+dbo.split(datea2,'-','1')))/60.0,1)
--where gno = '2'

--update @tmp set code = noa + code
update @tmp set datea1 = datea1+'<br>(入庫日期)' where gno = '1'
update @tmp set datea1 = dbo.split(datea1,'-',0)+'<br>'+dbo.split(datea1,'-',1)+'<br>(完成起時間)' ,datea2 = dbo.split(datea2,'-',0)+'<br>'+dbo.split(datea2,'-',1)+'<br>(完成訖時間)'where gno = '2'
update @tmp set datea1 = datea1+'<br>(出庫日期)' where gno = '3'

--105/07/13 工時合計
insert into @tmp(gno,rec,noa,times)
select '4',MAX(rec)+1,noa,SUM(times) from @tmp group by noa

--補空白行(25行)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select noa from @tmp group by noa
open cursor_table 
fetch next from cursor_table 
into @noa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where noa = @noa)
	set @max = (select MAX(rec) from @tmp where noa = @noa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,noa)
		select '5',@max+1,@noa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @noa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by noa,rec;
--**************************************************************************
z_modout_rs03:--z_modout_rs03

SET QUOTED_IDENTIFIER OFF

declare @t_bnob nvarchar(30)
declare @t_enob nvarchar(30)

set @t_bnob= case when '#non' = [5] then '' else [5] end
set @t_enob= case when '#non' = [6] then char(255) else [6] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	modnoa nvarchar(50),
	noa nvarchar(50),	
	nob nvarchar(50),
	detail nvarchar(50),
	class nvarchar(10),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	datea1 nvarchar(50),
	datea2 nvarchar(50),
	times float,
	mount float,
	mech  nvarchar(40),
	worker  nvarchar(10)
)
insert into @tmp(gno,rec,modnoa,noa,nob,detail,class,weight,way,datea1,mount,mech)
select '1',ROW_NUMBER()over(order by a.noa),a.modnoa,a.noa,b.nob,b.detail1,'入庫維修',b.weight1,b.way1,a.datea,b.mount1,a.mech
from modfix a
left join modfixs b on a.noa=b.noa
where nob between @t_bnob and @t_enob

declare @rec int
declare @noa nvarchar(50)
declare @nob nvarchar(50)

declare cursor_table cursor for 
select rec,noa,nob from @tmp where gno='1'
open cursor_table 
fetch next from cursor_table 
into @rec,@noa,@nob
while(@@FETCH_STATUS <> -1) 
begin
	insert into @tmp
	select '2',@rec,a.modnoa,a.noa,b.nob,b.detail,'維修',b.weight,b.bebottom,b.enbottom,b.way,b.bdate+'-'+b.btime,b.edate+'-'+b.etime,0,b.mount,a.mech,b.worker
	from modfixc a
	left join modfixcs b on a.noa=b.noa
	where a.innoa=@noa and b.nob=@nob 
	
	fetch next from cursor_table 
	into @rec,@noa,@nob
end 
close cursor_table 
deallocate cursor_table 

update @tmp set times =
	ROUND((DATEDIFF(minute,CAST(dbo.ChineseEraName2AD(dbo.split(datea1,'-','0'))as nvarchar(20))+' '+dbo.split(datea1,'-','1') ,CAST(dbo.ChineseEraName2AD(dbo.split(datea2,'-','0'))as nvarchar(20))+' '+dbo.split(datea2,'-','1')))/60.0,1)
where gno = '2'

declare cursor_table cursor for 
select rec,noa,nob from @tmp where gno='2'
open cursor_table 
fetch next from cursor_table 
into @rec,@noa,@nob
while(@@FETCH_STATUS <> -1) 
begin
	insert into @tmp(gno,rec,modnoa,noa,nob,detail,class,datea1,mount,mech)
	select '3',@rec,a.modnoa,a.noa,b.nob,b.detail,'領用出庫',a.datea,b.mount,a.mech
	from modout a
	left join modouts b on a.noa=b.noa
	where a.fixnoa=@noa and b.nob=@nob 
	
	fetch next from cursor_table 
	into @rec,@noa,@nob
end 
close cursor_table 
deallocate cursor_table

--補空白行(25行)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select nob from @tmp group by nob
open cursor_table 
fetch next from cursor_table 
into @nob
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where nob = @nob)
	set @max = (select MAX(rec) from @tmp where nob = @nob)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,nob)
		select '4',@max+1,@nob
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @nob
end 
close cursor_table 
deallocate cursor_table

select 
	a.*,
	b.tgg,b.datea,b.frame,case when b.usetype='1' then '製造課' else '設備課' end usetype
	,c.mount tmount
from @tmp a
left join model b on a.modnoa=b.noa
left join models c on a.modnoa=c.noa and c.productno=a.nob
order by a.nob,rec,gno;
--**************************************************************************
z_modout_rs04:--z_modout_rs04

declare @t_bdate nvarchar(20)
declare @t_edate nvarchar(20)
declare @t_worker nvarchar(100)

set @t_bdate = case when '#non' = [7] then ''  else [7] end
set @t_edate = case when '#non' = [8] then char(255) else [8] end
set @t_worker = case when '#non' = [9] then '' else [9] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	datea nvarchar(20),
	worker nvarchar(50),
	noa nvarchar(50),
	detail nvarchar(50),
	class nvarchar(50),
	mech nvarchar(40),
	weight float,
	bebottom float,
	enbottom float,
	way nvarchar(30),
	indate nvarchar(30),
	b2edate nvarchar(50),
	mount float
	
)
insert into @tmp
select 
	'1',ROW_NUMBER()over(partition by a.datea order by b.worker),a.datea,b.worker,b.nob,
	b.detail,'維修',a.mech,SUM(c.weight1),MIN(b.bebottom),MIN(b.enbottom),b.way,isnull((select datea from modfix where noa=a.innoa),'')
	,MIN(b.bdate+'-'+b.btime)+'~'+MAX(b.edate+'-'+b.etime),SUM(b.mount)
from modfixc a
left join modfixcs b on a.noa = b.noa
left join modfixs  c on b.nob = c.nob
where(a.datea between @t_bdate and @t_edate) and (@t_worker = '' or b.worker = @t_worker)
group by a.datea,b.worker,b.nob,b.detail,a.mech,b.way,a.innoa

--補空白行(25行)
declare @datea  nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select datea from @tmp group by datea
open cursor_table 
fetch next from cursor_table 
into @datea
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where datea = @datea)
	set @max = (select MAX(rec) from @tmp where datea = @datea)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,datea)
		select '2',@max+1,@datea
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @datea
end 
close cursor_table 
deallocate cursor_table

update @tmp set b2edate='' where b2edate='-~-'

select * from @tmp order by datea,rec;
--**************************************************************************
z_modout_rs05:--z_modout_rs05

declare @t_bmodnoa nvarchar(50)
declare @t_emodnoa nvarchar(50)
declare @t_frame nvarchar(50)

set @t_bmodnoa= case when '#non' = [3] then '' else [3] end
set @t_emodnoa= case when '#non' = [4] then char(255) else [4] end
set @t_frame = case when '#non' = [10] then '' else [10] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	modnoa nvarchar(50),
	frame nvarchar(30),
	noa nvarchar(50),
	detail nvarchar(50),
	class nvarchar(50),
	mech nvarchar(40),
	weight nvarchar(40),
	bebottom float,
	enbottom float,
	way nvarchar(30),
	indate nvarchar(30),
	mount float,
	worker nvarchar(50)
)
insert into @tmp
select 
	'1',ROW_NUMBER()over(partition by a.modnoa order by b.nob),a.modnoa,b.frame,b.nob,
	b.detail,'維修',a.mech,b.weight,b.bebottom,b.enbottom,b.way
	,isnull((select datea from modfix where noa=a.innoa),'') indate,b.mount,b.worker
from modfixc a
left join modfixcs b on a.noa = b.noa
where(a.modnoa between @t_bmodnoa and @t_emodnoa) and (LEN(@t_frame)=0 or b.frame=@t_frame) and
	 (ISNULL(b.fixmount,0)=0 and ISNULL(b.bebottom,0)=0 and ISNULL(b.enbottom,0)=0 and LEN(ISNULL(b.bdate,''))=0 and LEN(ISNULL(b.edate,''))=0)
	 and isnull(a.enda,0)=0
--group by a.modnoa,b.frame,b.nob,b.detail,a.mech,b.way,a.innoa

--補空白行(25行)
declare @modnoa  nvarchar(50)
declare @cnt  int
declare @max  int
declare @i    int

declare cursor_table cursor for 
select modnoa from @tmp group by modnoa
open cursor_table 
fetch next from cursor_table 
into @modnoa
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where modnoa = @modnoa)
	set @max = (select MAX(rec) from @tmp where modnoa = @modnoa)
	set @i = 0
	while(@i < 25-@cnt%25)
	begin
		insert into @tmp(gno,rec,modnoa)
		select '2',@max+1,@modnoa
			
		set @max = @max + 1
		set @i   = @i   + 1
	end
	
	fetch next from cursor_table 
	into @modnoa
end 
close cursor_table 
deallocate cursor_table

select * from @tmp order by modnoa,rec;
--**************************************************************************
z_modout_rs06:--z_modout_rs06

declare @t_date nvarchar(10) 

set @t_date = case when '#non' = [11] then ''  else [11] end
----------------------------------------------------------------------------
SET QUOTED_IDENTIFIER OFF

declare @tmp table(
	gno nvarchar(40),
	rec int,
	mech1 float,
	mech2 float,
	mech3 float,
	mech4 float,
	mech5 float,
	mech6 float,
	mech7 float,
	mech8 float,
	mech9 float,
	total1 float,
	total2 float
)

declare @mech nvarchar(max) = 'F01,F02,F03,F05,G01,G02,鑽床,銑床,插床'
declare @type nvarchar(max) = '成型段,定徑段'
declare @cmd  nvarchar(max) 
declare @gno int = 0
declare @i int = 0
declare @j int = 0

--本日成型段定徑段數量
while(@i < 2)
begin
	set @j = 0
	set @gno = @gno+1
	set @cmd = "select "+CAST(@gno as nvarchar(5))+",1,"
	while(@j < 9)
	begin
		set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
							from modfixcs 
							where (LEFT(detail,3)=dbo.split('"+@type+"',',',"+CAST(@i as nvarchar(5))+")) and 
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9)='"+@t_date+"' and LEFT(edate,9)='"+@t_date+"') 
							group by mech),"
		set @j = @j+1
	end
	set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
	insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd
	
	set @i = @i+1
end

--本日成型段定徑段數量合計
set @gno = @gno+1

insert into @tmp(gno,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9)
select @gno,SUM(mech1),SUM(mech2),SUM(mech3),SUM(mech4),SUM(mech5),SUM(mech6),SUM(mech7),SUM(mech8),SUM(mech9)
from @tmp where rec = 1

--本日成型段定徑段產量
set @i = 0
set @j = 0
while(@i < 2)
begin
	set @j = 0
	set @gno = @gno+1
	set @cmd = "select "+CAST(@gno as nvarchar(5))+",2,"
	while(@j < 9)
	begin
		set @cmd = @cmd + "(select SUM(ISNULL(weight,0)) 
							from modfixcs 
							where (LEFT(detail,3)=dbo.split('"+@type+"',',',"+CAST(@i as nvarchar(5))+")) and 
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9)='"+@t_date+"' and LEFT(edate,9)='"+@t_date+"') 
							group by mech),"
		set @j = @j+1
	end
	set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
	insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd
	
	set @i = @i+1
end

--本日成型段定徑段產量合計
set @gno = @gno+1

insert into @tmp(gno,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9)
select @gno,SUM(mech1),SUM(mech2),SUM(mech3),SUM(mech4),SUM(mech5),SUM(mech6),SUM(mech7),SUM(mech8),SUM(mech9)
from @tmp where rec = 2

--累積成型段定徑段數量
set @i = 0
set @j = 0
while(@i < 2)
begin
	set @j = 0
	set @gno = @gno+1
	set @cmd = "select "+CAST(@gno as nvarchar(5))+",3,"
	while(@j < 9)
	begin
		set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
							from modfixcs 
							where (LEFT(detail,3)=dbo.split('"+@type+"',',',"+CAST(@i as nvarchar(5))+")) and 
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between LEFT('"+@t_date+"',6)+'/01' and '"+@t_date+"') 
							group by mech),"
		set @j = @j+1
	end
	set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
	insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd
	
	set @i = @i+1
end

--累積成型段定徑段數量合計
set @gno = @gno+1

insert into @tmp(gno,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9)
select @gno,SUM(mech1),SUM(mech2),SUM(mech3),SUM(mech4),SUM(mech5),SUM(mech6),SUM(mech7),SUM(mech8),SUM(mech9)
from @tmp where rec = 3

--累積成型段定徑段產量
set @i = 0
set @j = 0
while(@i < 2)
begin
	set @j = 0
	set @gno = @gno+1
	set @cmd = "select "+CAST(@gno as nvarchar(5))+",4,"
	while(@j < 9)
	begin
		set @cmd = @cmd + "(select SUM(ISNULL(weight,0)) 
							from modfixcs 
							where (LEFT(detail,3)=dbo.split('"+@type+"',',',"+CAST(@i as nvarchar(5))+")) and 
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between LEFT('"+@t_date+"',6)+'/01' and '"+@t_date+"')  
							group by mech),"
		set @j = @j+1
	end
	set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
	insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd
	
	set @i = @i+1
end

--累積成型段定徑段產量合計
set @gno = @gno+1

insert into @tmp(gno,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9)
select @gno,SUM(mech1),SUM(mech2),SUM(mech3),SUM(mech4),SUM(mech5),SUM(mech6),SUM(mech7),SUM(mech8),SUM(mech9)
from @tmp where rec = 4

--加班數量
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",5,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
						from modfixcs 
						where (worktype='加班')and						  
							  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
							  (LEFT(bdate,9)='"+@t_date+"' and LEFT(edate,9)='"+@t_date+"')   
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

--加班數量累計
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",6,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
						from modfixcs 
						where (worktype='加班')and
							  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
							  (LEFT(bdate,9) between LEFT('"+@t_date+"',6)+'/01' and '"+@t_date+"') 
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

--加班工時
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",7,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(CAST(DATEDIFF(mi,bdate,edate)/60.0 as numeric(5,1))) from(
							select mech,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+btime bdate,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+etime edate
							from modfixcs 
							where (worktype='加班')and
								  (fixmount > 0) and 	 	
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9)='"+@t_date+"' and LEFT(edate,9)='"+@t_date+"')
							)t
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
print @cmd
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

--加班工時累計
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",8,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(CAST(DATEDIFF(mi,bdate,edate)/60.0 as numeric(5,1))) from(
							select mech,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+btime bdate,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+etime edate
							from modfixcs 
							where (worktype='加班')and
								  (fixmount > 0) and 	
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between LEFT('"+@t_date+"',6)+'/01' and '"+@t_date+"') 
							)t
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

--機台合計
update @tmp set mech1=ISNULL(mech1,0),mech2=ISNULL(mech2,0),mech3=ISNULL(mech3,0),mech4=ISNULL(mech4,0),
				mech5=ISNULL(mech5,0),mech6=ISNULL(mech6,0),mech7=ISNULL(mech7,0),mech8=ISNULL(mech8,0),mech9=ISNULL(mech9,0)

update @tmp set total1 = mech1+mech2+mech3+mech4,total2 = mech5+mech6

select 
	gno,rec,
	dbo.getComma(mech1,-1)mech1,dbo.getComma(mech2,-1)mech2,dbo.getComma(mech3,-1)mech3,dbo.getComma(mech4,-1)mech4,dbo.getComma(mech5,-1)mech5,
	dbo.getComma(mech6,-1)mech6,dbo.getComma(mech7,-1)mech7,dbo.getComma(mech8,-1)mech8,dbo.getComma(mech9,-1)mech9,
	dbo.getComma(total1,-1)ttl1,dbo.getComma(total2,-1)ttl2
from @tmp;
 --**************************************************************************
z_modout_rs07:--z_modout_rs07

SET QUOTED_IDENTIFIER OFF

declare @t_bdate nvarchar(20)
declare @t_edate nvarchar(20)

set @t_bdate = case when '#non' = [7] then ''  else [7] end
set @t_edate = case when '#non' = [8] then char(255) else [8] end
----------------------------------------------------------------------------
declare @tmp table(
	gno nvarchar(1),
	rec int,
	bdate nvarchar(10),
	mechs nvarchar(40),
	detial nvarchar(50),
	modnoa nvarchar(50),
	frame1 nvarchar(10),
	mount1 float,
	weight1 float,
	frame2 nvarchar(10),
	mount2 float,
	weight2 float,
	mech nvarchar(40),
	worker nvarchar(50)
)
insert into @tmp
select 
	'1',ROW_NUMBER()over(partition by LEFT(b.bdate,9) order by b.nob),LEFT(bdate,9),b.mech,b.detail,b.nob,
	case when LEFT(b.detail,3)='成型段' then b.frame  else null end,
	case when LEFT(b.detail,3)='成型段' then SUM(b.fixmount)  else null end,
	case when LEFT(b.detail,3)='成型段' then SUM(b.weight) else null end,
	case when LEFT(b.detail,3)='定徑段' then b.frame  else null end,
	case when LEFT(b.detail,3)='定徑段' then SUM(b.fixmount)  else null end,
	case when LEFT(b.detail,3)='定徑段' then SUM(b.weight) else null end,
	a.mech,b.worker
from modfixc a 
left join modfixcs b on a.noa = b.noa
where (LEFT(bdate,9) between @t_bdate and @t_edate) and (fixmount > 0)
group by LEFT(bdate,9),b.mech,b.detail,b.nob,b.frame,a.mech,b.worker

--補空白行
declare @bdate nvarchar(10)
declare @xbdate nvarchar(10)='zzzzzz'
declare @cnt int
declare @max int
declare @i int

declare cursor_table cursor for 
select bdate from @tmp group by bdate 
open cursor_table 
fetch next from cursor_table 
into @bdate
while(@@FETCH_STATUS <> -1) 
begin
	set @cnt = (select COUNT(*) from @tmp where bdate = @bdate)
	set @max = (select MAX(rec) from @tmp where bdate = @bdate)

	set @i = 0
	set @cnt = case when @cnt%22=0 then 0 else 22-@cnt%22 end
	while(@i < @cnt)
	begin
		insert into @tmp(gno,rec,bdate)
		select '1',@max+@i+1,@bdate
		
		set @i = @i+1
	end
	
	fetch next from cursor_table 
	into @bdate
end 
close cursor_table 
deallocate cursor_table 

insert into @tmp(gno,rec,bdate)
select '2',rec,bdate from @tmp where rec%22 = 0

select *,
	   dbo.getComma(mount1,0)mnt1,dbo.getComma(weight1,0)wei1,dbo.getComma(mount2,0)mnt2,dbo.getComma(weight2,0)wei2 
from @tmp order by bdate,rec,gno;
--**************************************************************************
z_modout_rs08:--z_modout_rs08

declare @t_bdate nvarchar(20)
declare @t_edate nvarchar(20)

set @t_bdate = case when '#non' = [7] then ''  else [7] end
set @t_edate = case when '#non' = [8] then char(255) else [8] end
-----------------------------------------------------------------------------
SET QUOTED_IDENTIFIER OFF

declare @tmp table(
	gno nvarchar(40),
	rec int,
	mech1 float,
	mech2 float,
	mech3 float,
	mech4 float,
	mech5 float,
	mech6 float,
	mech7 float,
	mech8 float,
	mech9 float,
	total1 float,
	total2 float
)

declare @mech nvarchar(max) = 'F01,F02,F03,F05,G01,G02,鑽床,銑床,插床'
declare @type nvarchar(max) = '成型段,定徑段'
declare @cmd  nvarchar(max) 
declare @gno int = 0
declare @i int
declare @j int

--累積成型段定徑段數量
set @i = 0
set @j = 0
while(@i < 2)
begin
	set @j = 0
	set @gno = @gno+1
	set @cmd = "select "+CAST(@gno as nvarchar(5))+",1,"
	while(@j < 9)
	begin
		set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
							from modfixcs 
							where (LEFT(detail,3)=dbo.split('"+@type+"',',',"+CAST(@i as nvarchar(5))+")) and 
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between '"+@t_bdate+"' and '"+@t_edate+"') 
							group by mech),"
		set @j = @j+1
	end
	set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
	insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd
	
	set @i = @i+1
end

--累積成型段定徑段數量合計
set @gno = @gno+1

insert into @tmp(gno,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9)
select @gno,SUM(mech1),SUM(mech2),SUM(mech3),SUM(mech4),SUM(mech5),SUM(mech6),SUM(mech7),SUM(mech8),SUM(mech9)
from @tmp where rec = 1

--累積成型段定徑段產量
set @i = 0
set @j = 0
while(@i < 2)
begin
	set @j = 0
	set @gno = @gno+1
	set @cmd = "select "+CAST(@gno as nvarchar(5))+",2,"
	while(@j < 9)
	begin
		set @cmd = @cmd + "(select SUM(ISNULL(weight,0)) 
							from modfixcs 
							where (LEFT(detail,3)=dbo.split('"+@type+"',',',"+CAST(@i as nvarchar(5))+")) and 
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between '"+@t_bdate+"' and '"+@t_edate+"')   
							group by mech),"
		set @j = @j+1
	end
	set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
	insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd
	
	set @i = @i+1
end

--累積成型段定徑段產量合計
set @gno = @gno+1

insert into @tmp(gno,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9)
select @gno,SUM(mech1),SUM(mech2),SUM(mech3),SUM(mech4),SUM(mech5),SUM(mech6),SUM(mech7),SUM(mech8),SUM(mech9)
from @tmp where rec = 2

/*--加班數量
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",3,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
						from modfixcs 
						where (worktype='加班')and
							  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
							  (LEFT(bdate,9)='"+@t_date+"' and LEFT(edate,9)='"+@t_date+"')   
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd*/

--加班數量累計
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",4,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(ISNULL(fixmount,0)) 
						from modfixcs 
						where (worktype='加班')and
							  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
							  (LEFT(bdate,9) between '"+@t_bdate+"' and '"+@t_edate+"')  
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

/*--加班工時
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",5,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(CAST(DATEDIFF(mi,bdate,edate)/60.0 as numeric(5,1))) from(
							select mech,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+RIGHT(bdate,5) bdate,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+RIGHT(edate,5) edate
							from modfixcs 
							where (worktype='加班')and
								  (fixmount > 0) and 	
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9)='"+@t_date+"' and LEFT(edate,9)='"+@t_date+"')
							group by mech,bdate,edate)t
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd*/

--加班工時累計
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",6,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(CAST(DATEDIFF(mi,bdate,edate)/60.0 as numeric(5,1))) from(
							select mech,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+btime bdate,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+etime edate
							from modfixcs 
							where (worktype='加班')and
								  (fixmount > 0) and 	
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between '"+@t_bdate+"' and '"+@t_edate+"')  
							)t
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

--生產工時累計
set @j = 0
set @gno = @gno+1
set @cmd = "select "+CAST(@gno as nvarchar(5))+",7,"
while(@j < 9)
begin
	set @cmd = @cmd + "(select SUM(CAST(DATEDIFF(mi,bdate,edate)/60.0 as numeric(5,1))) from(
							select mech,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+btime bdate,CAST(dbo.ChineseEraName2AD(LEFT(bdate,9))as nvarchar(10))+' '+etime edate
							from modfixcs 
							where (fixmount > 0) and 	
								  (mech=dbo.split('"+@mech+"',',',"+CAST(@j as nvarchar(5))+")) and
								  (LEFT(bdate,9) between '"+@t_bdate+"' and '"+@t_edate+"')  
						)t
						group by mech),"
	set @j = @j+1
end
set @cmd = LEFT(@cmd,LEN(@cmd)-1) 
insert into @tmp(gno,rec,mech1,mech2,mech3,mech4,mech5,mech6,mech7,mech8,mech9) execute sp_executesql @cmd

--機台合計
update @tmp set mech1=ISNULL(mech1,0),mech2=ISNULL(mech2,0),mech3=ISNULL(mech3,0),mech4=ISNULL(mech4,0),
				mech5=ISNULL(mech5,0),mech6=ISNULL(mech6,0),mech7=ISNULL(mech7,0),mech8=ISNULL(mech8,0),mech9=ISNULL(mech9,0)

update @tmp set total1 = mech1+mech2+mech3+mech4,total2 = mech5+mech6

select 
	gno,rec,
	dbo.getComma(mech1,-1)mech1,dbo.getComma(mech2,-1)mech2,dbo.getComma(mech3,-1)mech3,dbo.getComma(mech4,-1)mech4,dbo.getComma(mech5,-1)mech5,
	dbo.getComma(mech6,-1)mech6,dbo.getComma(mech7,-1)mech7,dbo.getComma(mech8,-1)mech8,dbo.getComma(mech9,-1)mech9,
	dbo.getComma(total1,-1)ttl1,dbo.getComma(total2,-1)ttl2
from @tmp;